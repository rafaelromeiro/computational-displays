<!DOCTYPE html>
<html>
	<head>
		<title>Stereoscopic Lightfield Test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style> body { margin: 0px } </style>
	</head>
	
	<body>
        <center>
        <h1>Parameter Configuration</h1>
        <p> Aperture array hole diameter (mm): <br><input id="da" type="number" value=0.2></p>
        <p> Aperture array center-to-center distance (mm): <br><input id="da+db" type="number" value=1.8></p>
        <p> Aperture array distance to screen (mm): <br><input id="dai" type="number" value=13></p>
        <p> Max pupil size (mm): <br><input id="de" type="number" value=10></p>
        <p> Interpupilar distance (mm): <br><input id="ipd" type="number" value=64.7></p>
        <p> Screen size (inches): <br><input id="screen_size" type="number" value=5.5></p>
        <button style="font-size : 20px; height : 70px; width : 300px" onclick="applyConfiguration();">Apply (and launch fullscreen)</button><p>
        </center>
		<div id="container"></div>
		<script src="js/three.min.js"></script>
		
		<script id="vertexShader" type="x-shader/x-vertex">
			void main() {
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform float time;
            uniform float ipd;
            uniform float elemental_size;
            uniform float screen_size;
            uniform float screen_distance;
            uniform float pinhole_distance;
            uniform float pinhole_scale;
			
			uniform sampler2D texture1;
            uniform sampler2D texture2;

			void main() {
                vec4 background_color = vec4(0.4, 0.4, 0.6, 1.0);
                
				float pixel_to_mm = screen_size / length(resolution);
                
                // scs -> screen space
                // eys -> eye space
                // obs -> object space
				
				vec2 screen_center = resolution / 2.0;
				vec2 p_scs = (gl_FragCoord.xy - screen_center) * pixel_to_mm;
                
                vec2 eye_center_scs = vec2(sign(p_scs.x) * ipd / 2.0, 0.0);
                vec2 p_eys = p_scs - eye_center_scs;
                
				vec2 elemental_image_eys = floor(p_eys / elemental_size);
                vec2 elemental_center_eys = (elemental_image_eys + 0.5) * elemental_size;
                
                vec2 pinhole_eys = elemental_center_eys * pinhole_scale;
                vec2 pinhole_scs = pinhole_eys + eye_center_scs;
                    
                vec3 pinhole_wos = vec3(pinhole_scs, -pinhole_distance);
                vec3 light_direction = pinhole_wos - vec3(p_scs, -screen_distance);
                
                vec3 up = vec3(0.0, 1.0, 0.0);
                
                vec3 object_center = vec3(0.0, 0.0, -1000);
                vec2 object_size = vec2(500.0, 500.0);
                vec3 object_normal = vec3(sin(time*0.3), 0.0, cos(time*0.3));
                vec3 object_normal2 = cross(up, object_normal);
                
                float t1 = (dot(pinhole_wos, object_normal) - dot(object_center, object_normal) ) / dot(light_direction, object_normal);
                float t2 = (dot(pinhole_wos, object_normal2) - dot(object_center, object_normal2) ) / dot(light_direction, object_normal2);
                vec3 p1 = pinhole_wos - light_direction * t1;
                vec3 p2 = pinhole_wos - light_direction * t2;
                
                float y1 = dot(p1 - object_center, up);
                float x1 = dot(p1 - object_center - up * y1, cross(up, object_normal));
                float y2 = dot(p2 - object_center, up);
                float x2 = dot(p2 - object_center - up * y2, cross(up, object_normal2));
                
                vec2 p_tex1 = vec2(x1, y1) / object_size + 0.5;
                vec2 p_tex2 = vec2(x2, y2) / object_size + 0.5;
                
                vec4 color1 = texture2D( texture1, p_tex1 );
                vec4 color2 = texture2D( texture2, p_tex2 );
                
                gl_FragColor = background_color;
                
                if (t1 > t2) {
                    if (p_tex1.x >= 0.0 && p_tex1.y >= 0.0 && p_tex1.x <= 1.0 && p_tex1.y <= 1.0)
                        gl_FragColor = color1;
                    if (p_tex2.x >= 0.0 && p_tex2.y >= 0.0 && p_tex2.x <= 1.0 && p_tex2.y <= 1.0)
                        gl_FragColor = color2;
                }
                else {
                    if (p_tex2.x >= 0.0 && p_tex2.y >= 0.0 && p_tex2.x <= 1.0 && p_tex2.y <= 1.0)
                        gl_FragColor = color2;
                    if (p_tex1.x >= 0.0 && p_tex1.y >= 0.0 && p_tex1.x <= 1.0 && p_tex1.y <= 1.0)
                        gl_FragColor = color1;
                }
			}
		</script>

		<script>
			var container;
			var camera, scene, renderer;
			var uniforms;
			
			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				camera = new THREE.Camera();
				camera.position.z = 1;

				scene = new THREE.Scene();

				var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

				uniforms = {
					time: { type: "f", value: 1.0 },
                    ipd: { type: "f", value: 1.0 },
                    elemental_size: { type: "f", value: 1.0 },
                    screen_size: { type: "f", value: 1.0 },
                    screen_distance: { type: "f", value: 1.0 },
                    pinhole_distance: { type: "f", value: 1.0 },
                    pinhole_scale: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2()},
					texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "images/lenna.png" )},
                    texture2: { type: "t", value: THREE.ImageUtils.loadTexture( "images/baboon.png" )}
				};

				var material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
				} );

				var mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				container.appendChild( renderer.domElement );

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize( event ) {
				renderer.setSize( window.innerWidth, window.innerHeight );

				uniforms.resolution.value.x = renderer.domElement.width;
				uniforms.resolution.value.y = renderer.domElement.height;
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				uniforms.time.value += 0.05;
				renderer.render( scene, camera );
			}
            
            function applyConfiguration() {
                da = document.getElementById("da").value - 0.0;
                db = document.getElementById("da+db").value - da;
                de = document.getElementById("de").value - 0.0;
                dai = document.getElementById("dai").value- 0.0;
                dae = dai * (de - db) / db;
                dl = de * (da + db) / (de - db);
                
                uniforms.ipd.value = document.getElementById("ipd").value - 0.0;
                uniforms.elemental_size.value = dl;
                uniforms.screen_size.value = 25.4 * document.getElementById("screen_size").value;
                uniforms.screen_distance.value = dai + dae;
                uniforms.pinhole_distance.value = dae - da * dai / (dl - da);
                uniforms.pinhole_scale.value = uniforms.pinhole_distance.value / (dai + dae);
                
                window.alert("Screen distance to eye should be " + uniforms.screen_distance.value + " mm");
                
                launchFullscreen(document.getElementById( 'container' ));
            }
            
            function launchFullscreen(element) {
                if(element.requestFullscreen) {
                    element.requestFullscreen();
                } else if(element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if(element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if(element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            }

		</script>

	</body>
</html>
